{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"snippet": {
		"prefix": "snippet",
		"body": [
			"bool isPrime(int n) {",
			"  if (n == 2 || n == 3) {",
			"    return true;",
			"  }",
			"  if (n <= 1 || n % 2 == 0 || n % 3 == 0) {",
			"    return false;",
			"  }",
			"  for (int i = 5; i * i <= n; i += 6) {",
			"    if (n % i == 0 || n % (i + 2) == 0) {",
			"      return false;",
			"    }",
			"  }",
			"  return true;",
			"}",
			"",
			"bool isPowerof(long long num, long long base) {",
			"  if (num <= 0) {",
			"    return false;",
			"  }",
			"  if (num % base == 0) {",
			"    return isPowerof(num / base, base);",
			"  }",
			"  if (num == 1) {",
			"    return true;",
			"  }",
			"  return false;",
			"}",
			"",
			"long long powmod(long long a, long long b, long long MOD) {",
			"  long long res = 1;",
			"  a %= MOD;",
			"  assert(b >= 0);",
			"  for (; b; b >>= 1) {",
			"    if (b & 1) res = res * a % MOD;",
			"    a = a * a % MOD;",
			"  }",
			"  return res;",
			"}",
			"",
			"long long binpow(long long a, long long b) {",
			"  if (b == 0)",
			"    return 1;",
			"  long long res = binpow(a, b / 2);",
			"  if (b % 2)",
			"    return res * res * a;",
			"  else",
			"    return res * res;",
			"}",
			"",
			"bool palindrome_check(string s) {",
			"  string temp = s;",
			"  reverse(temp.begin(), temp.end());",
			"  if (temp != s) {",
			"    return false;",
			"  }",
			"  return true;",
			"}",
			"",
			"bool isSubstring(string s1, string s2) {",
			"  // using find method to check if s1 is",
			"  // a substring of s2",
			"  if (s2.find(s1) != string::npos)",
			"    return s2.find(s1);",
			"  return false;",
			"}",
			"",
			"int remainder(string str, int n) {",
			"  int len = str.length();",
			"  int num, rem = 0;",
			"  for (int i = 0; i < len; i++) {",
			"    num = rem * 10 + (str[i] - '0');",
			"    rem = num % n;",
			"  }",
			"  return rem;",
			"}",
			"",
			"string longDivision(string number, int divisor) {",
			"  string ans;",
			"  int idx = 0;",
			"  int temp = number[idx] - '0';",
			"  while (temp < divisor)",
			"    temp = temp * 10 + (number[++idx] - '0');",
			"",
			"  while (number.size() > idx) {",
			"    ans += (temp / divisor) + '0';",
			"    temp = (temp % divisor) * 10 + number[++idx] - '0';",
			"  }",
			"",
			"  if (ans.length() == 0)",
			"    return \"0\";",
			"",
			"  return ans;",
			"}",
			"",
			"//bitwise sieve"
			"bool Check(int N, int pos) { return (bool)(N & (1 << pos)); }",
			"int Set(int N, int pos) { return N = N | (1 << pos); }",
			" ",
			"const int mx = 100000000;",
			"int N = mx;",
			"int status[(mx / 32) + 2];",
			"vector<int> primes;",
			"void sieve() {",
			"    int i, j, sqrtN, cnt = 1;",
			"    sqrtN = int(sqrt(N));",
			"    for (i = 3; i <= sqrtN; i += 2) {",
			"        if (Check(status[i >> 5], i & 31) == 0) {",
			"            cnt++;",
			"            for (j = i * i; j <= N; j += (i << 1)) {",
			"                status[j >> 5] = Set(status[j >> 5], j & 31);",
			"            }",
			"        }",
			"    }",
			"    primes.push_back(2);",
			" ",
			"    for (i = 3; i <= N; i += 2) {",
			"        if (Check(status[i >> 5], i & 31) == 0) {",
			"            primes.push_back(i);",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"cpp": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"#define all(x) x.begin(),x.end()",
			"#define rall(x) x.rbegin(),x.rend()",
			"#define minimum(x) *min_element(x.begin(),x.end())",
			"#define maximum(x) *max_element(x.begin(),x.end())",
			"",
			"// debug section",
			"",
			"void __print(int x) { cerr << x; }",
			"void __print(long x) { cerr << x; }",
			"void __print(long long x) { cerr << x; }",
			"void __print(unsigned x) { cerr << x; }",
			"void __print(unsigned long x) { cerr << x; }",
			"void __print(unsigned long long x) { cerr << x; }",
			"void __print(float x) { cerr << x; }",
			"void __print(double x) { cerr << x; }",
			"void __print(long double x) { cerr << x; }",
			"void __print(char x) { cerr << '\\'' << x << '\\''; }",
			"void __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
			"template <typename A>",
			"void __print(const A &x);",
			"template <typename A, typename B>",
			"void __print(const pair<A, B> &p);",
			"template <typename... A>",
			"void __print(const tuple<A...> &t);",
			"template <typename T>",
			"void __print(stack<T> s);",
			"template <typename T>",
			"void __print(queue<T> q);",
			"template <typename T, typename... U>",
			"void __print(priority_queue<T, U...> q);",
			"template <typename A>",
			"void __print(const A &x) {",
			"    bool first = true;",
			"    cerr << '{';",
			"    for (const auto &i : x) {",
			"        cerr << (first ? \"\" : \",\"), __print(i);",
			"        first = false;",
			"    }",
			"    cerr << '}';",
			"}",
			"template <typename A, typename B>",
			"void __print(const pair<A, B> &p) {",
			"    cerr << '(';",
			"    __print(p.first);",
			"    cerr << ',';",
			"    __print(p.second);",
			"    cerr << ')';",
			"}",
			"template <typename... A>",
			"void __print(const tuple<A...> &t) {",
			"    bool first = true;",
			"    cerr << '(';",
			"    apply([&first](const auto &...args) { ((cerr << (first ? \"\" : \"	\"), __print(args), first = false), ...); }, t);",
			"    cerr << ')';",
			"}",
			"template <typename T>",
			"void __print(stack<T> s) {",
			"    vector<T> debugVector;",
			"    while (!s.empty()) {",
			"        T t = s.top();",
			"        debugVector.push_back(t);",
			"        s.pop();",
			"    }",
			"    reverse(debugVector.begin(), debugVector.end());",
			"    __print(debugVector);",
			"}",
			"template <typename T>",
			"void __print(queue<T> q) {",
			"    vector<T> debugVector;",
			"    while (!q.empty()) {",
			"        T t = q.front();",
			"        debugVector.push_back(t);",
			"        q.pop();",
			"    }",
			"    __print(debugVector);",
			"}",
			"template <typename T, typename... U>",
			"void __print(priority_queue<T, U...> q) {",
			"    vector<T> debugVector;",
			"    while (!q.empty()) {",
			"        T t = q.top();",
			"        debugVector.push_back(t);",
			"        q.pop();",
			"    }",
			"    __print(debugVector);",
			"}",
			"",
			"template <typename T>",
			"void __print(const T arr[], int size) {",
			"    bool first = true;",
			"    cerr << '[';",
			"    for (int i = 0; i < size; ++i) {",
			"        cerr << (first ? \"\" : \",\");",
			"        __print(arr[i]);",
			"        first = false;",
			"    }",
			"    cerr << ']' << '\\n';",
			"}",
			"void _print() { cerr << \"]\\n\"; }",
			"template <typename Head, typename... Tail>",
			"void _print(const Head &H, const Tail &...T) {",
			"    __print(H);",
			"    if (sizeof...(T))",
			"        cerr << \", \";",
			"    _print(T...);",
			"}",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(...) cerr << \"Line:\" << __LINE__ << \" [\" <<	#__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__)",
			"#define debug_array(arr, size) cerr << \"Line:\" << __LINE__ << \" [\"	<< #arr << \"] = \"; __print(arr, size)",
			"#else",
			"#define debug(...)",
			"#define debug_array(...)",
			"#endif"
		  "",
		  "int32_t main() {",
		  "",
		  "    ios_base::sync_with_stdio(false);",
		  "    cin.tie(nullptr);",
		  "",
		  "    int T; ",
		  "    cin >> T;",
		  "    for(int testCase = 1; testCase <= T; testCase++) {",
		  "    ",
		  "\t\t$0",
		  "        // cout << \"Case \" << testCase << \": \" << ;",
		  "    }",
		  "    return 0;",
		  "}"
		],
		"description": ""
	  },
	  "debug": {
		"prefix": "debug",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"#ifdef ONLINE_JUDGE",
			"#define debug(...) 42",
			"#define debug_array(x,y) 42",
			"#else",
			"#include \"deBUG.h\"",
			"#endif",
			"",
			"void attack() {",
			"\t$0",
			"}",
			"",
			"int32_t main() {",
			"",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int T; ",
			"    cin >> T;",
			"    for(int testCase = 1; testCase <= T; testCase++) {",
			"    ",
			"        attack();",
			"        // cout << \"Case \" << testCase << \": \" << ;",
			"    }",
			"    return 0;",
			"}"
		],
		"description": ""
	  },
	  "isPrime": {
		"prefix": "isPrime",
		"body": [
		  "bool isPrime(int n) {",
		  "    if (n == 2 || n == 3) {",
		  "        return true;",
		  "    }",
		  "    if (n <= 1 || n % 2 == 0 || n % 3 == 0) {",
		  "        return false;",
		  "    }",
		  "    for (int i = 5; i * i <= n; i += 6) {",
		  "        if (n % i == 0 || n % (i + 2) == 0) {",
		  "            return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "bitwiseSieve": {
		"prefix": "bitwiseSieve",
		"body": [
		  "bool Check(int N, int pos) {",
		  "    return (bool)(N & (1 << pos));",
		  "}",
		  "int Set(int N, int pos) {",
		  "    return N = N | (1 << pos);",
		  "}",
		  "",
		  "const int mx = 100000000;",
		  "int N = mx;",
		  "int status[(mx / 32) + 2];",
		  "vector < int > primes;",
		  "void sieve() {",
		  "    int i, j, sqrtN, cnt = 1;",
		  "    sqrtN = int(sqrt(N));",
		  "    for (i = 3; i <= sqrtN; i += 2) {",
		  "        if (Check(status[i >> 5], i & 31) == 0) {",
		  "            cnt++;",
		  "            for (j = i * i; j <= N; j += (i << 1)) {",
		  "                status[j >> 5] = Set(status[j >> 5], j & 31);",
		  "            }",
		  "        }",
		  "    }",
		  "    primes.push_back(2);",
		  "",
		  "    for (i = 3; i <= N; i += 2) {",
		  "        if (Check(status[i >> 5], i & 31) == 0) {",
		  "            primes.push_back(i);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "bitsetSieve": {
		"prefix": "bitsetSieve",
		"body": [
		  "const int N = 1e6 + 9;",
		  "bitset < N > isPrime;",
		  "void sieve() {",
		  "    isPrime.set();",
		  "    isPrime[1] = 0;",
		  "    for (int i = 2; i * i < N; i++) {",
		  "        if (isPrime[i]) {",
		  "            for (int j = i * i; j < N; j += i) {",
		  "                isPrime[j] = 0;",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "vector < int > prime;",
		  "prime.push_back(0);",
		  "prime.push_back(2);",
		  "for (int i = 3; i < N; i += 2)",
		  "    if (is_prime[i]) prime.push_back(i);"
		],
		"description": ""
	  },
	  "divisor": {
		"prefix": "divisor",
		"body": [
		  "vector < int > divs;",
		  "for (int i = 1; i * i <= n; i++) {",
		  "    if (n % i == 0) {",
		  "        divs.push_back(i);",
		  "        if (i != n / i) divs.push_back(n / i);",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "powmod": {
		"prefix": "powmod",
		"body": [
		  "long long powmod(long long a, long long b, long long MOD) {",
		  "    long long res = 1;",
		  "    a %= MOD;",
		  "    assert(b >= 0);",
		  "    for (; b; b >>= 1) {",
		  "        if (b & 1) res = res * a % MOD;",
		  "        a = a * a % MOD;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "binpow": {
		"prefix": "binpow",
		"body": [
		  "long long binpow(long long a, long long b) {",
		  "    if (b == 0)",
		  "        return 1;",
		  "    long long res = binpow(a, b / 2);",
		  "    if (b % 2)",
		  "        return res * res * a;",
		  "    else",
		  "        return res * res;",
		  "}"
		],
		"description": ""
	  },
	  "customHash": {
		"prefix": "customHash",
		"body": [
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "    size_t operator()(uint64_t x) const {",
		  "        static",
		  "        const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};"
		],
		"description": ""
	  }
}