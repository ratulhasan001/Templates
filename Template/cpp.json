{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"snippet": {
		"prefix": "snippet",
		"body": [
			"bool isPrime(int n) {",
			"  if (n == 2 || n == 3) {",
			"    return true;",
			"  }",
			"  if (n <= 1 || n % 2 == 0 || n % 3 == 0) {",
			"    return false;",
			"  }",
			"  for (int i = 5; i * i <= n; i += 6) {",
			"    if (n % i == 0 || n % (i + 2) == 0) {",
			"      return false;",
			"    }",
			"  }",
			"  return true;",
			"}",
			"",
			"bool isPowerof(long long num, long long base) {",
			"  if (num <= 0) {",
			"    return false;",
			"  }",
			"  if (num % base == 0) {",
			"    return isPowerof(num / base, base);",
			"  }",
			"  if (num == 1) {",
			"    return true;",
			"  }",
			"  return false;",
			"}",
			"",
			"long long powmod(long long a, long long b, long long MOD) {",
			"  long long res = 1;",
			"  a %= MOD;",
			"  assert(b >= 0);",
			"  for (; b; b >>= 1) {",
			"    if (b & 1) res = res * a % MOD;",
			"    a = a * a % MOD;",
			"  }",
			"  return res;",
			"}",
			"",
			"long long binpow(long long a, long long b) {",
			"  if (b == 0)",
			"    return 1;",
			"  long long res = binpow(a, b / 2);",
			"  if (b % 2)",
			"    return res * res * a;",
			"  else",
			"    return res * res;",
			"}",
			"",
			"bool palindrome_check(string s) {",
			"  string temp = s;",
			"  reverse(temp.begin(), temp.end());",
			"  if (temp != s) {",
			"    return false;",
			"  }",
			"  return true;",
			"}",
			"",
			"bool isSubstring(string s1, string s2) {",
			"  // using find method to check if s1 is",
			"  // a substring of s2",
			"  if (s2.find(s1) != string::npos)",
			"    return s2.find(s1);",
			"  return false;",
			"}",
			"",
			"int remainder(string str, int n) {",
			"  int len = str.length();",
			"  int num, rem = 0;",
			"  for (int i = 0; i < len; i++) {",
			"    num = rem * 10 + (str[i] - '0');",
			"    rem = num % n;",
			"  }",
			"  return rem;",
			"}",
			"",
			"string longDivision(string number, int divisor) {",
			"  string ans;",
			"  int idx = 0;",
			"  int temp = number[idx] - '0';",
			"  while (temp < divisor)",
			"    temp = temp * 10 + (number[++idx] - '0');",
			"",
			"  while (number.size() > idx) {",
			"    ans += (temp / divisor) + '0';",
			"    temp = (temp % divisor) * 10 + number[++idx] - '0';",
			"  }",
			"",
			"  if (ans.length() == 0)",
			"    return \"0\";",
			"",
			"  return ans;",
			"}",
			"",
			"//bitwise sieve",
			"bool Check(int N, int pos) { return (bool)(N & (1 << pos)); }",
			"int Set(int N, int pos) { return N = N | (1 << pos); }",
			" ",
			"const int mx = 100000000;",
			"int N = mx;",
			"int status[(mx / 32) + 2];",
			"vector<int> primes;",
			"void sieve() {",
			"    int i, j, sqrtN, cnt = 1;",
			"    sqrtN = int(sqrt(N));",
			"    for (i = 3; i <= sqrtN; i += 2) {",
			"        if (Check(status[i >> 5], i & 31) == 0) {",
			"            cnt++;",
			"            for (j = i * i; j <= N; j += (i << 1)) {",
			"                status[j >> 5] = Set(status[j >> 5], j & 31);",
			"            }",
			"        }",
			"    }",
			"    primes.push_back(2);",
			" ",
			"    for (i = 3; i <= N; i += 2) {",
			"        if (Check(status[i >> 5], i & 31) == 0) {",
			"            primes.push_back(i);",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"cpp": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"#define all(x) x.begin(),x.end()",
			"#define rall(x) x.rbegin(),x.rend()",
			"#define minimum(x) *min_element(x.begin(),x.end())",
			"#define maximum(x) *max_element(x.begin(),x.end())",
			"",
			"// debug section",
			"",
			"void __print(int x) { cerr << x; }",
			"void __print(long x) { cerr << x; }",
			"void __print(long long x) { cerr << x; }",
			"void __print(unsigned x) { cerr << x; }",
			"void __print(unsigned long x) { cerr << x; }",
			"void __print(unsigned long long x) { cerr << x; }",
			"void __print(float x) { cerr << x; }",
			"void __print(double x) { cerr << x; }",
			"void __print(long double x) { cerr << x; }",
			"void __print(char x) { cerr << '\\'' << x << '\\''; }",
			"void __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
			"template <typename A>",
			"void __print(const A &x);",
			"template <typename A, typename B>",
			"void __print(const pair<A, B> &p);",
			"template <typename... A>",
			"void __print(const tuple<A...> &t);",
			"template <typename T>",
			"void __print(stack<T> s);",
			"template <typename T>",
			"void __print(queue<T> q);",
			"template <typename T, typename... U>",
			"void __print(priority_queue<T, U...> q);",
			"template <typename A>",
			"void __print(const A &x) {",
			"    bool first = true;",
			"    cerr << '{';",
			"    for (const auto &i : x) {",
			"        cerr << (first ? \"\" : \",\"), __print(i);",
			"        first = false;",
			"    }",
			"    cerr << '}';",
			"}",
			"template <typename A, typename B>",
			"void __print(const pair<A, B> &p) {",
			"    cerr << '(';",
			"    __print(p.first);",
			"    cerr << ',';",
			"    __print(p.second);",
			"    cerr << ')';",
			"}",
			"template <typename... A>",
			"void __print(const tuple<A...> &t) {",
			"    bool first = true;",
			"    cerr << '(';",
			"    apply([&first](const auto &...args) { ((cerr << (first ? \"\" : \"	\"), __print(args), first = false), ...); }, t);",
			"    cerr << ')';",
			"}",
			"template <typename T>",
			"void __print(stack<T> s) {",
			"    vector<T> debugVector;",
			"    while (!s.empty()) {",
			"        T t = s.top();",
			"        debugVector.push_back(t);",
			"        s.pop();",
			"    }",
			"    reverse(debugVector.begin(), debugVector.end());",
			"    __print(debugVector);",
			"}",
			"template <typename T>",
			"void __print(queue<T> q) {",
			"    vector<T> debugVector;",
			"    while (!q.empty()) {",
			"        T t = q.front();",
			"        debugVector.push_back(t);",
			"        q.pop();",
			"    }",
			"    __print(debugVector);",
			"}",
			"template <typename T, typename... U>",
			"void __print(priority_queue<T, U...> q) {",
			"    vector<T> debugVector;",
			"    while (!q.empty()) {",
			"        T t = q.top();",
			"        debugVector.push_back(t);",
			"        q.pop();",
			"    }",
			"    __print(debugVector);",
			"}",
			"",
			"template <typename T>",
			"void __print(const T arr[], int size) {",
			"    bool first = true;",
			"    cerr << '[';",
			"    for (int i = 0; i < size; ++i) {",
			"        cerr << (first ? \"\" : \",\");",
			"        __print(arr[i]);",
			"        first = false;",
			"    }",
			"    cerr << ']' << '\\n';",
			"}",
			"void _print() { cerr << \"]\\n\"; }",
			"template <typename Head, typename... Tail>",
			"void _print(const Head &H, const Tail &...T) {",
			"    __print(H);",
			"    if (sizeof...(T))",
			"        cerr << \", \";",
			"    _print(T...);",
			"}",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(...) cerr << \"Line:\" << __LINE__ << \" [\" <<	#__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__)",
			"#define debug_array(arr, size) cerr << \"Line:\" << __LINE__ << \" [\"	<< #arr << \"] = \"; __print(arr, size)",
			"#else",
			"#define debug(...)",
			"#define debug_array(...)",
			"#endif",
		  "",
		  "int32_t main() {",
		  "",
		  "    ios_base::sync_with_stdio(false);",
		  "    cin.tie(nullptr);",
		  "",
		  "    int T; ",
		  "    cin >> T;",
		  "    for(int testCase = 1; testCase <= T; testCase++) {",
		  "    ",
		  "\t\t$0",
		  "        // cout << \"Case \" << testCase << \": \" << ;",
		  "    }",
		  "    return 0;",
		  "}"
		],
		"description": ""
	  },
	  "basic": {
		"prefix": "basic",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "int main() {",
		  "",
		  "    int test;",
		  "    cin >> test;",
		  "    while(test--) {",
		  "\t\t$0",
		  "    }",
		  "    ",
		  "    return 0;",
		  "}"
		],
		"description": ""
	  },
	  "debug": {
		"prefix": "debug",
		"body": [
			"#pragma GCC optimization (\"O3\")",
    		"#pragma GCC optimization (\"unroll-loops\")",
			"",
			"#include <bits/stdc++.h>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"using u128 = __uint128_t;",
			"using ull = unsigned long long;",
			"using pii = pair < int, int >;",
			"using pll = pair < ll, ll >;",
			"template <typename T> using ordered_set = tree<T, null_type, less<T>,",
			"rb_tree_tag,  tree_order_statistics_node_update>;",			
			"",
			"#define all(x) x.begin(),x.end()",
			"#define rall(x) x.rbegin(),x.rend()",
			"#define minimum(x) *min_element(x.begin(),x.end())",
			"#define maximum(x) *max_element(x.begin(),x.end())",
			"",
			"#ifdef ONLINE_JUDGE",
			"#define debug(...) 31",
			"#define debug_array(x,y) 31",
			"#else",
			"#include \"deBUG.h\"",
			"#endif",
			"",
			"void hello_world() {",
			"\t$0",
			"}",
			"",
			"int32_t main() {",
			"",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int T; ",
			"    cin >> T;",
			"    for(int testCase = 1; testCase <= T; testCase++) {",
			"    ",
			"        hello_world();",
			"        // cout << \"Case \" << testCase << \": \" << ;",
			"    }",
			"    return 0;",
			"}"
		],
		"description": ""
	  },
	  "isPrime": {
		"prefix": "isPrime",
		"body": [
		  "bool isPrime(int n) {",
		  "    if (n == 2 || n == 3) {",
		  "        return true;",
		  "    }",
		  "    if (n <= 1 || n % 2 == 0 || n % 3 == 0) {",
		  "        return false;",
		  "    }",
		  "    for (int i = 5; i * i <= n; i += 6) {",
		  "        if (n % i == 0 || n % (i + 2) == 0) {",
		  "            return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "bitwiseSieve": {
		"prefix": "bitwiseSieve",
		"body": [
		  "bool Check(int N, int pos) {",
		  "    return (bool)(N & (1 << pos));",
		  "}",
		  "int Set(int N, int pos) {",
		  "    return N = N | (1 << pos);",
		  "}",
		  "",
		  "const int mx = 100000000;",
		  "int N = mx;",
		  "int status[(mx / 32) + 2];",
		  "vector < int > primes;",
		  "void sieve() {",
		  "    int i, j, sqrtN, cnt = 1;",
		  "    sqrtN = int(sqrt(N));",
		  "    for (i = 3; i <= sqrtN; i += 2) {",
		  "        if (Check(status[i >> 5], i & 31) == 0) {",
		  "            cnt++;",
		  "            for (j = i * i; j <= N; j += (i << 1)) {",
		  "                status[j >> 5] = Set(status[j >> 5], j & 31);",
		  "            }",
		  "        }",
		  "    }",
		  "    primes.push_back(2);",
		  "",
		  "    for (i = 3; i <= N; i += 2) {",
		  "        if (Check(status[i >> 5], i & 31) == 0) {",
		  "            primes.push_back(i);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "bitsetSieve": {
		"prefix": "bitsetSieve",
		"body": [
		  "const int N = 1e6 + 9;",
		  "bitset < N > isPrime;",
		  "void sieve() {",
		  "    isPrime.set();",
		  "    isPrime[1] = 0;",
		  "    for (int i = 2; i * i < N; i++) {",
		  "        if (isPrime[i]) {",
		  "            for (int j = i * i; j < N; j += i) {",
		  "                isPrime[j] = 0;",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "vector < int > prime;",
		  "prime.push_back(0);",
		  "prime.push_back(2);",
		  "for (int i = 3; i < N; i += 2)",
		  "    if (is_prime[i]) prime.push_back(i);"
		],
		"description": ""
	  },
	  "divisor": {
		"prefix": "divisor",
		"body": [
		  "vector < int > divs;",
		  "for (int i = 1; i * i <= n; i++) {",
		  "    if (n % i == 0) {",
		  "        divs.push_back(i);",
		  "        if (i != n / i) divs.push_back(n / i);",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "powmod": {
		"prefix": "powmod",
		"body": [
		  "long long powmod(long long a, long long b, long long MOD) {",
		  "    long long res = 1;",
		  "    a %= MOD;",
		  "    assert(b >= 0);",
		  "    for (; b; b >>= 1) {",
		  "        if (b & 1) res = res * a % MOD;",
		  "        a = a * a % MOD;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "binpow": {
		"prefix": "binpow",
		"body": [
		  "long long binpow(long long a, long long b) {",
		  "    if (b == 0)",
		  "        return 1;",
		  "    long long res = binpow(a, b / 2);",
		  "    if (b % 2)",
		  "        return res * res * a;",
		  "    else",
		  "        return res * res;",
		  "}"
		],
		"description": ""
	  },
	  "customHash": {
		"prefix": "customHash",
		"body": [
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "    size_t operator()(uint64_t x) const {",
		  "        static",
		  "        const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "isSubstring": {
		"prefix": "isSubstring",
		"body": [
		  "bool isSubstring(string s1, string s2) {",
		  "  // using find method to check if s1 is",
		  "  // a substring of s2",
		  "  if (s2.find(s1) != string::npos)",
		  "    return s2.find(s1);",
		  "  return false;",
		  "}"
		],
		"description": ""
	  },
	  "execution": {
		"prefix": "execution",
		"body": [
		  "clock_t START = clock();",
		  "clock_t END = clock();",
		  "cout << 1.0 * (END - START) / CLOCKS_PER_SEC << '\\n';"
		],
		"description": ""
	  },
	  "onlyDebug": {
		"prefix": "onlyDebug",
		"body": [
			"#ifdef ONLINE_JUDGE",
			"#define debug(...) 31",
			"#define debug_array(x,y) 31",
			"#else",
			"#include \"deBUG.h\"",
			"#endif",
		],
		"description": ""
	  },
	  "orderedSet": {
		"prefix": "orderedSet",
		"body": [
		  "#include<ext/pb_ds/assoc_container.hpp>",
		  "#include<ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "template <typename T> using ordered_set = tree<T, null_type, less<T>, ",
		  "rb_tree_tag,  tree_order_statistics_node_update>;"
		],
		"description": ""
	  },
	  "MillerRabin": {
		"prefix": "MillerRabin",
		"body": [
		  "ull binpower(ull base, ull e, ull mod) {",
		  "    ull result = 1;",
		  "    base %= mod;",
		  "    while (e) {",
		  "        if (e & 1) result = (u128) result * base % mod;",
		  "        base = (u128) base * base % mod;",
		  "        e >>= 1;",
		  "    }",
		  "    return result;",
		  "}",
		  "",
		  "bool check_composite(ull n, ull a, ull d, int s) {",
		  "    ull x = binpower(a, d, n);",
		  "    if (x == 1 || x == n - 1) return false;",
		  "    for (int r = 1; r < s; r++) {",
		  "        x = (u128) x * x % n;",
		  "        if (x == n - 1) return false;",
		  "    }",
		  "    return true;",
		  "};",
		  "",
		  "bool MillerRabin(ull n) {",
		  "    if (n < 2) return false;",
		  "    int r = 0;",
		  "    ull d = n - 1;",
		  "    while ((d & 1) == 0) {",
		  "        d >>= 1;",
		  "        r++;",
		  "    }",
		  "    for (int a: {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
		  "        if (n == a) return true;",
		  "        if (check_composite(n, a, d, r)) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "dfs": {
		"prefix": "dfs",
		"body": [
		  "const int N = 2e5 + 5;",
		  "vector < int > g[N];",
		  "vector < int > visited(N), depth(N), height(N);",
		  "",
		  "void dfs(int source) {",
		  "    visited[source] = true;",
		  "    //cout << \"Visiting node: \" << u << endl;",
		  "    for (int child : g[source]) {",
		  "        if (visited[child] == true) continue;",
		  "        depth[child] = depth[source] + 1;",
		  "        dfs(child);",
		  "        height[source] = max(height[source], height[child] + 1);",
		  "    }",
		  "}",
		  "",
		  "void reset_graph(int n) {",
		  "    for(int i = 0; i <= n; i++) {",
		  "        g[i].clear();",
		  "        visited[i] = depth[i] = height[i] = 0;",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "prime_factor": {
		"prefix": "prime_factor",
		"body": [
		  "const int MAXN = 1e6 + 5;",
		  "int spf[MAXN];",
		  "vector < int > factor[MAXN];",
		  "inline vector < int > getFactorization(int x) {",
		  "    vector < int > ret;",
		  "    while (x != 1) {",
		  "        ret.push_back(spf[x]);",
		  "        x = x / spf[x];",
		  "    }",
		  "    return ret;",
		  "}",
		  "void sievefactor() {",
		  "    spf[1] = 1;",
		  "    for (int i = 2; i <= MAXN; i++) {",
		  "        spf[i] = i;",
		  "    }",
		  "    for (int i = 4; i <= MAXN; i += 2) {",
		  "        spf[i] = 2;",
		  "    }",
		  "    for (int i = 3; i * i < MAXN; i++) {",
		  "        if (spf[i] == i) {",
		  "            for (int j = i * i; j < MAXN; j += i) {",
		  "                if (spf[j] == j) {",
		  "                    spf[j] = i;",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    for (int i = 1; i <= MAXN; i++) {",
		  "        factor[i] = getFactorization(i);",
		  "    }",
		  "}"
		],
		"description": ""
	  }
}